/*자료형과 관련된 학습 연장할 꺼임..*/
class TypeTest1{
	public static void main(String[] args){
		/* byte short int long float double char boolean */
		byte b=5; //1byte 숫자형
		short s=8; //2byte 숫자형
		//s=b; // O  작 --> 큰 들어가는건 당연히 가능
		//b=s; // X 큰 --> 작 들어가려니 데이터의 손실발생
		
		
		short s1=8;
		short s2=9;

		/*아래의 코드가 컴파일 에러가 발생하는 이유는? 
		고전적인 C언어를 포함하여, 현대의 컴퓨터 언어에 이르기까지 
		정수의 연산은 int를 기준으로 최적화되어 있기 때문에, 연산시 
		int이하의 자료형들은 컴파일러에 의해 자동으로 자료형을 int형으로 변환
		해 버린다...이러한 현상을 개발자가에 의해서가 아니라 시스템에 의한 
		형변환이므로 '자동형변환' 이라 한다
		참고) 왜 int 이하만 적용되는 이유는? 손실을 발생시키면서까지 속도를 올릴이유는
				없다
		*/
		short result = (short)(s1+s2); // +연산을 수행하기전에 시스템이 s1,s2를
										// int로 변환한 후, 연산을 수행한다!!
		//에러가 안 나게 하는법? 
		//해결책1) short result 를 int result 로 선언한다!! 
		//해결책2) 개발자가 손실을 감안하고, 그대로 강경하게 밀어붙임..
		//				강제 형변환이라 한다, 이때 (자료형) 소괄호를 cast 연산자라
		//				한다
		long x=65;
		int k=78;
		//컴파일러가 연산을 수행할때는 연산 대상이 되는 데이터는 무조건 같은
		//자료형으로 수평을 맞추고 나서 수행한다!!이때 데이터 손실이 발생하지 않도록
		//큰 자료형을 기준으로 형변환된다!!
		//long result2 = x+k; 
		//int result2 = (int)(x+k); 손실감안하면서까지 int로 강제 형변환
	}
}